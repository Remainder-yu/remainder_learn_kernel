# setup_arch简介-内存管理初始化

linux内存管理主要分成三个阶段：
1. MMU未打开时，还在汇编时代时。
2. fixmap、memblock时代，此时伙伴系统还未成形，一直到mem_init函数中的mem_init将空闲内存加载到zone中
3. 伙伴系统建立

## start_kernel

后续分析：start_kernel主要流程，其中和内存管理相关的系统初始化函数及原理。

引导程序负责加载内核映像文件并将控制权交给内核，从而启动操作系统。在x86架构下，引导程序通过设置中断向量表使CPU执行到内核的入口地址，从而调用start_kernel函数。
具体调用start_kernel函数的步骤如下：

1. 引导程序加载内核映像文件到内存中，一般是将内核映像文件加载到指定的物理内存地址。
2. 引导程序设置CPU的寄存器，包括设置CS（Code Segment）寄存器为内核的代码段选择子，设置EIP（Instruction Pointer）寄存器为内核的入口地址，也就是start_kernel函数的地址。
3. 引导程序发送中断指令（例如，int指令），触发中断异常。
4. CPU接收到中断异常后，根据中断向量表处理该中断。在引导程序设置的中断向量表中，将指定的中断向量与内核入口地址关联起来。
5. CPU根据中断向量表找到与该中断向量关联的内核入口地址，将CPU的控制权转移至该地址，即开始执行start_kernel函数。
需要注意的是，具体的实现会因不同的引导程序而有所差异。例如，GRUB引导程序使用Multiboot规范加载内核，并通过设置CPU的寄存器和中断向量表来调用start_kernel函数。而UEFI引导程序则有自己的加载方式和调用机制。因此，具体的调用过程会根据引导程序的不同而有所差异。

### bootmem
在Linux内核启动的早期阶段，物理内存的管理非常重要。在这个阶段，内核需要确定可用的物理内存范围，并为各种数据结构和功能分配内存空间。为了完成这些任务，Linux内核提供了bootmem分配器。
bootmem分配器是一种在内核启动期间使用的简单、高效的内存管理方式。它的目标是在内核启动早期，预留一段连续的物理内存，作为内核的运行空间，并为内核数据结构和功能分配内存。
具体来说，bootmem分配器的主要作用有以下几点：


1. 管理物理内存的分配和释放：bootmem分配器可以将物理内存划分为多个区域，并跟踪每个区域的可用和已分配状态。当内核需要分配内存时，bootmem分配器会检查可用内存并分配一块连续的内存区域。
2. 提供用于内核数据结构和功能的内存空间：在内核启动早期，许多重要的数据结构和功能需要预分配内存。例如，内核必须分配存储页表的内存、内核堆栈的内存、内核模块的内存等等。bootmem分配器可以在这个阶段为这些数据结构和功能提供必要的内存。
3. 支持动态内存分配器：bootmem分配器可以在内核启动阶段启用一个简单的动态内存分配器，提供基本的内存分配和释放功能。这样，在内核运行到后续阶段时，可以使用更复杂的内存分配器来管理内存。
需要注意的是，bootmem分配器只在内核启动阶段使用，并且在系统初始化完成后就不再起作用。后续的内存管理任务会由更高级的分配器（例如，SLAB分配器和SLUB分配器）接管，提供更灵活和高级的内存管理功能。


## setup_arch
在韦东山qemu_sdk中，是从 `arch/arm/kernel/setup.c`文件的 `void __init setup_arch(char **cmdline_p)`函数接口开始的。



参考：
[博客文章](https://blog.csdn.net/u012489236/category_9614673.html)
